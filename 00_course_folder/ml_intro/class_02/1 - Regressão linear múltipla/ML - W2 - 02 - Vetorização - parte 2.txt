Lembro-me de que, quando aprendi sobre vetorização pela primeira vez, passei muitas horas no meu computador pegando uma versão não vetorizada de um algoritmo que a executava, vendo por quanto tempo ela era executada e, em seguida, executando uma versão vetorizada do código e vendo o quão rápido ela era executada, e passei horas brincando com isso. E, francamente, me surpreendeu que o mesmo algoritmo vetorizado fosse executado muito mais rápido. Pareceu quase um truque de mágica para mim. Neste vídeo, vamos descobrir como esse truque de mágica realmente funciona. Vamos analisar mais detalhadamente como uma implementação vetorizada pode funcionar em seu computador nos bastidores. Vamos dar uma olhada nisso. O loop for como esse é executado sem vetorização. Se j varia de 0 a, digamos, 15, esse trecho de código executa operações uma após a outra. No primeiro carimbo de data/hora que vou escrever como t0. Ele opera primeiro nos valores no índice 0. Na próxima etapa de tempo, ele calcula os valores correspondentes ao índice 1 e assim por diante até a 15ª etapa, onde calcula isso. Em outras palavras, ele calcula esses cálculos uma etapa por vez, uma etapa após a outra. Em contraste, essa função no NumPy é implementada no hardware do computador com vetorização. O computador pode obter todos os valores dos vetores w e x e, em uma única etapa, multiplica cada par de w e x um com o outro ao mesmo tempo em paralelo. Depois disso, o computador pega esses 16 números e usa hardware especializado para adicioná-los de forma muito eficiente, em vez de precisar realizar adições distintas, uma após a outra, para somar esses 16 números. Isso significa que códigos com vetorização podem realizar cálculos em muito menos tempo do que códigos sem vetorização. Isso é mais importante quando você está executando algoritmos em grandes conjuntos de dados ou tentando treinar modelos grandes, o que geralmente acontece com o aprendizado de máquina. É por isso que ser capaz de vetorizar implementações de algoritmos de aprendizado tem sido uma etapa fundamental para fazer com que os algoritmos de aprendizado funcionem com eficiência e, portanto, escalem bem para grandes conjuntos de dados nos quais muitos algoritmos modernos de aprendizado de máquina agora precisam operar. Agora, vamos dar uma olhada em um exemplo concreto de como isso ajuda na implementação da regressão linear múltipla e dessa regressão linear com vários recursos de entrada. Digamos que você tenha um problema com 16 recursos e 16 parâmetros, w1 a w16, além do parâmetro b. Você calcula 16 termos derivados para esses 16 pesos e códigos, talvez armazene os valores de w e d em duas matrizes np, com d armazenando os valores das derivadas. Neste exemplo, vou simplesmente ignorar o parâmetro b. Agora, você deseja calcular uma atualização para cada um desses 16 parâmetros.
Reproduza o vídeo começando em :3:24 e siga a transcrição3:24
W_j é atualizado para w_j menos a taxa de aprendizado, digamos 0,1, vezes d_j, para j de 1 a 16. Codifica sem vetorização, você estaria fazendo algo assim. Atualize w1 para w1 menos a taxa de aprendizado 0,1 vezes d1, em seguida, atualize w2 da mesma forma e assim por diante até w16, atualizado como w16 menos 0,1 vezes d16.
Reproduza o vídeo começando em :4:5 e siga a transcrição4:05
Codifica sem vetorização, você pode usar um loop for como este para j no intervalo 016, que novamente vai de 0 a 15, dizendo que w_j é igual a w_j menos 0,1 vezes d_j. Em contraste, com a fatoração, você pode imaginar o hardware de processamento paralelo do computador assim. Ele pega todos os 16 valores no vetor w e subtrai em paralelo, 0,1 vezes todos os 16 valores no vetor d, e atribui todos os 16 cálculos de volta a w ao mesmo tempo e tudo em uma única etapa. No código, você pode implementar isso da seguinte forma: w é atribuído a w menos 0,1 vezes d. Nos bastidores, o computador usa essas matrizes NumPy, w e d, e usa hardware de processamento paralelo para realizar todos os 16 cálculos de forma eficiente. Usando uma implementação vetorizada, você deve obter uma implementação muito mais eficiente da regressão linear. Talvez a diferença de velocidade não seja grande se você tiver 16 recursos, mas se você tiver milhares de recursos e talvez conjuntos de treinamento muito grandes, esse tipo de implementação vetorizada fará uma grande diferença no tempo de execução do seu algoritmo de aprendizado. Pode ser a diferença entre códigos que terminam em um ou dois minutos e demoram muitas horas para fazer a mesma coisa. No laboratório opcional que segue este vídeo, você vê uma introdução a uma das bibliotecas Python e ao aprendizado de máquina mais usadas, que já abordamos neste vídeo chamado NumPy. Você vê como eles criam vetores, codificam e esses vetores ou listas de números são chamados de matrizes NumPy, e você também vê como obter o produto escalar de dois vetores usando uma função NumPy chamada ponto. Você também pode ver como o código vetorizado, como o uso da função dot, pode ser executado muito mais rápido do que um for-loop. Na verdade, você mesmo conseguiria cronometrar esse código e, com sorte, vê-lo rodar muito mais rápido. Este laboratório opcional apresenta uma boa quantidade de nova sintaxe NumPy, portanto, ao ler o laboratório opcional , ainda sinta que precisa entender todo o código imediatamente, mas você pode salvar este caderno e usá-lo como referência quando estiver trabalhando com dados armazenados em matrizes NumPy. Parabéns por terminar este vídeo sobre vetorização. Você aprendeu uma das técnicas mais importantes e úteis na implementação de algoritmos de aprendizado de máquina. No próximo vídeo, colocaremos a matemática da regressão linear múltipla junto com a vetorização, para que você influencie o gradiente descendente na regressão linear múltipla com vetorização. Vamos para o próximo vídeo.
